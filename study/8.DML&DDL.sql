-- 2022/10/06 THURSDAY!!

ALTER TABLE SQLD.TB_DEPT_TEMP DROP PRIMARY KEY;

DROP TABLE SQLD.TB_DEPT_TEMP PURGE;
DROP TABLE SQLD.TB_DEPT_TEMP CASCADE CONSTRAINTS;

CREATE TABLE SQLD.TB_DEPT_TEMP
	(
	  DEPT_CD CHAR(6) NOT NULL
	, DETP_NM VARCHAR2(150) NOT NULL
	, UPPER_DEPT_CD CHAR(6)
	);
ALTER TABLE SQLD.TB_DEPT_TEMP ADD CONSTRAINTS PK_TB_DEPT_TEMP PRIMARY KEY (DEPT_CD);

SELECT * FROM SQLD.TB_DEPT_TEMP;

----------------------------------

DROP TABLE SQLD.TB_EMP_TEMP PURGE;

CREATE TABLE SQLD.TB_EMP_TEMP
	(
	  EMP_NO CHAR(10) NOT NULL
	, EMP_NM VARCHAR2(150) NOT NULL
	, BIRTH_DE CHAR(8) NOT NULL
	, LUNAR_YN CHAR(1) NOT NULL
	, SEX_CD CHAR(3) NOT NULL
	, ADDR VARCHAR2(1000) NOT NULL
	, TEL_NO VARCHAR2(150) NOT NULL
	, FINAL_EDU_SE_CD CHAR(3) NOT NULL
	, SAL_TRANS_BANK_CD CHAR(3) NOT NULL
	, SAL_TRANS_ACCNT_NO VARCHAR2(20) NOT NULL
	, DIRECT_MANAGER_EMP_NO CHAR(10) NOT NULL
	, DEPT_CD CHAR(6) NOT NULL
	);
ALTER TABLE SQLD.TB_EMP_TEMP ADD CONSTRAINTS PK_TB_EMP_TEMP PRIMARY KEY (EMP_NO);

SELECT * FROM SQLD.TB_EMP_TEMP;

-- TB_EMP 테이블에서 TB_DEPT 테이의 DEPT_CD 컬럼을 참조하는 FK생성
ALTER TABLE SQLD.TB_EMP_TEMP ADD CONSTRAINTS FK_TB_EMP_TEMP_01 FOREIGN KEY (DEPT_CD) REFERENCES SQLD.TB_DEPT_TEMP (DEPT_CD);



-- ALTER TABLE
	-- ADD COLUMN 
	ALTER TABLE SQLD.TB_EMP_TEMP ADD (MARRIED_YN CHAR(1)); 
	-- DROP COLUMN
	ALTER TABLE SQLD.TB_EMP_TEMP DROP COLUMN MARRIED_YN;
	-- MODIFY COLUMN
	ALTER TABLE SQLD.TB_EMP_TEMP ADD (MARRIED_YN CHAR(1));
	ALTER TABLE SQLD.TB_EMP_TEMP MODIFY (MARRIED_YN CHAR(1) DEFAULT 'N' NOT NULL NOVALIDATE);
	ALTER TABLE SQLD.TB_EMP_TEMP DROP COLUMN MARRIED_YN;

	-- RENAME COLUMN
	CREATE TABLE SQLD.TB_EMP_TEMP_2 AS SELECT * FROM SQLD.TB_EMP_TEMP;
	ALTER TABLE SQLD.TB_EMP_TEMP_2 RENAME COLUMN TEL_NO TO PHONE_NO;
	ALTER TABLE SQLD.TB_EMP_TEMP_2 RENAME COLUMN PHONE_NO TO TEL_NO;
	SELECT * FROM SQLD.TB_EMP_TEMP_2;

	-- *************************************************************************************************************************
	-- 이게 염병할 무결설 제약 조건 삭제하는 거구나......
	-- DROP CONSTRAINT
	ALTER TABLE SQLD.TB_EMP_TEMP DROP CONSTRAINT FK_TB_EMP_TEMP_01;
	-- *************************************************************************************************************************

	-- 이게 추가라면....
	ALTER TABLE SQLD.TB_EMP_TEMP ADD CONSTRAINTS FK_TB_EMP_TEMP_01 FOREIGN KEY (DEPT_CD) REFERENCES SQLD.TB_DEPT_TEMP (DEPT_CD);

-- 테이블명 변경
RENAME SQLD.TB_EMP_TEMP_2 TO TB_EMP_TEMP_3;	-- 이거 왜 안되는거야..
SELECT * FROM SQLD.TB_EMP_TEMP_2;

-- TRUNCATE TABLE : 테이블 데이터 비우기 -> ROLLVACK 불가능.
TRUNCATE TABLE SQLD.TB_EMP_TEMP_2;

-- 테이블 삭제
DROP TABLE SQLD.TB_EMP_TEMP_2;

-- TEST
	CREATE TABLE SQLD.DT_TEST 
		(
		  CUST_NO CHAR(10)
		, SAL NUMBER(15,2)
		);
	ALTER TABLE SQLD.DT_TEST ADD CONSTRAINTS PK_DT_TEST PRIMARY KEY (CUST_NO);
	
	INSERT INTO SQLD.DT_TEST (CUST_NO, SAL) VALUES ('A',1);
	-- INSERT INTO SQLD.DT_TEST (CUST_NO, SAL) VALUES ('A',1); -- CUST_NO가 PK자나 똑같은 값 중복 할 수 없어...(무결성제약조건)
	INSERT INTO SQLD.DT_TEST (CUST_NO, SAL) VALUES ('B',2);
	SELECT * FROM SQLD.DT_TEST;
	
	-- CUST_NO가 CHAR형이자나 A하나만 넣었지만 길이는 10인것을 확인해 볼 수 있다.
	SELECT LENGTH(CUST_NO) FROM SQLD.DT_TEST;

	-- TEST2
	CREATE TABLE SQLD.DT_TEST_2
	(
	  CUST_NO VARCHAR2(10)
	, SAL NUMBER(15,2)
	);

	INSERT INTO SQLD.DT_TEST_2 (CUST_NO, SAL) VALUES ('ABCDEFGHIJ', 2);
	INSERT INTO SQLD.DT_TEST_2 (CUST_NO, SAL) VALUES ('ABCDEFGHI', 3);
	INSERT INTO SQLD.DT_TEST_2 (CUST_NO, SAL) VALUES ('ABCDEFGHI', '');		-- NUMBER형이어도 NULL말고 ''해도 NULL로 들어가는구나
	SELECT LENGTH(CUST_NO), SAL FROM SQLD.DT_TEST_2;
	SELECT * FROM SQLD.DT_TEST_2;



----------------------------------------------------------DML----------------------------------------------------------

	INSERT INTO SQLD.TB_CERTI (CERTI_CD, CERTI_NM, ISSUE_INSTI_NM) VALUES ('100021', 'SQLD합격패스', 'FAST CAMPAS');
	
	SELECT * FROM SQLD.TB_CERTI;
	
	UPDATE SQLD.TB_CERTI
	SET ISSUE_INSTI_NM = 'SLOW CAMPAS'
	WHERE CERTI_CD  = '100021';
	
	DELETE FROM SQLD.TB_CERTI WHERE CERTI_CD = '100021';

	-- 중복 없이 조회 : DISTINCT
	SELECT DISTINCT * FROM SQLD.TB_CERTI;

	-- 선두로 보고싶은 컬럼이있을땐? KKK -> 이런식으로 플래그가 있어야하는군.
	SELECT KKK.TEL_NO, KKK.* FROM SQLD.TB_EMP KKK;

	-- ALIAS지정! LG에서 신나게 했었지?	--> AS : 컬럼명을 AS이하로 보여 주겠다는 뜻.
	-- AS생략 가능한데 있어야지 보기가 편하겠지?
	SELECT 
	  CERTI_CD AS 자격증코드
	, CERTI_NM AS 자격증명
	, ISSUE_INSTI_NM AS 발급기관명
	FROM SQLD.TB_CERTI;

	-- 합성연산자를 써보자.	-> ||연산자를 이용하여 문자열을 연결 할 수 있다.
	SELECT CERTI_NM || '(' || CERTI_CD || ')' || '-' || ISSUE_INSTI_NM AS CERTI_INFO FROM SQLD.TB_CERTI;

	-- DUAL테이블 : 그냥 제공해주는 빈테이블 같은 거야	 -> SYS계정이 가지고 있어. SELECT * FROM SYS.DUAL; 해봐 궁금하면
	SELECT 'ABCD' AS TEST FROM DUAL;